"use strict";var R=Object.defineProperty;var S=Object.getOwnPropertyDescriptor;var P=Object.getOwnPropertyNames;var w=Object.prototype.hasOwnProperty;var N=(n,e)=>{for(var t in e)R(n,t,{get:e[t],enumerable:!0})},D=(n,e,t,a)=>{if(e&&typeof e=="object"||typeof e=="function")for(let s of P(e))!w.call(n,s)&&s!==t&&R(n,s,{get:()=>e[s],enumerable:!(a=S(e,s))||a.enumerable});return n};var V=n=>D(R({},"__esModule",{value:!0}),n);var _={};N(_,{Index:()=>b});module.exports=V(_);var i=class extends Error{constructor(e){super(e),this.name="UpstashError"}};var f=class{baseUrl;headers;options;retry;constructor(e){this.options={cache:e.cache,signal:e.signal},this.baseUrl=e.baseUrl.replace(/\/$/,""),this.headers={"Content-Type":"application/json",...e.headers},typeof e?.retry=="boolean"&&e?.retry===!1?this.retry={attempts:1,backoff:()=>0}:this.retry={attempts:e?.retry?.retries??5,backoff:e?.retry?.backoff??(t=>Math.exp(t)*50)}}async request(e){let t={cache:this.options.cache,method:"POST",headers:this.headers,body:JSON.stringify(e.body),keepalive:!0,signal:this.options.signal},a=null,s=null;for(let g=0;g<=this.retry.attempts;g++)try{a=await fetch([this.baseUrl,...e.path??[]].join("/"),t);break}catch(A){if(this.options.signal?.aborted){let M=new Blob([JSON.stringify({result:this.options.signal.reason??"Aborted"})]),U={status:200,statusText:this.options.signal.reason??"Aborted"};a=new Response(M,U);break}s=A,await new Promise(M=>setTimeout(M,this.retry.backoff(g)))}if(!a)throw s??new Error("Exhausted all retries");let o=await a.json();if(!a.ok)throw new i(`${o.error}`);return{result:o.result,error:o.error}}};var r=class{payload;endpoint;constructor(e,t){this.payload=e,this.endpoint=t}async exec(e){let{result:t,error:a}=await e.request({body:this.payload,path:[this.endpoint]});if(a)throw new i(a);if(typeof t>"u")throw new Error("Request did not return a result");return t}};var p=class extends r{constructor(e,t){let a="delete";t?.namespace&&(a=`${a}/${t.namespace}`);let s=[];Array.isArray(e)?s.push(...e):s.push(e),super(s,a)}};var d=class extends r{constructor(e,t){let a="query";"data"in e&&(a="query-data"),t?.namespace&&(a=`${a}/${t.namespace}`),super(e,a)}};var m=class extends r{constructor(e,t){let a="upsert";if(Array.isArray(e)){if(e.some(o=>"data"in o&&o.data)){a="upsert-data";for(let o of e)!("metadata"in o)&&"data"in o&&(o.metadata={data:o.data})}}else"data"in e&&(a="upsert-data","metadata"in e||(e.metadata={data:e.data}));t?.namespace&&(a=`${a}/${t.namespace}`),super(e,a)}};var c=class extends r{constructor([e,t]){let a="fetch";t?.namespace&&(a=`${a}/${t.namespace}`,delete t.namespace),super({ids:e,...t},a)}};var l=class extends r{constructor(e,t){let a="range";t?.namespace&&(a=`${a}/${t.namespace}`),super(e,a)}};var u=class extends r{constructor(e){let t="reset";e?.namespace&&(t=`${t}/${e.namespace}`),super([],t)}};var T=class extends r{constructor(){super([],"info")}};var h=class{client;namespace;constructor(e,t){this.client=e,this.namespace=t}upsert=e=>new m(e,{namespace:this.namespace}).exec(this.client);update=e=>new y(e,{namespace:this.namespace}).exec(this.client);fetch=(...e)=>(e[1]?e[1].namespace=this.namespace:e[1]={namespace:this.namespace},new c(e).exec(this.client));query=e=>new d(e,{namespace:this.namespace}).exec(this.client);delete=e=>new p(e,{namespace:this.namespace}).exec(this.client);range=e=>new l(e,{namespace:this.namespace}).exec(this.client);reset=()=>new u({namespace:this.namespace}).exec(this.client)};var y=class extends r{constructor(e,t){let a="update";t?.namespace&&(a=`${a}/${t.namespace}`),super(e,a)}};var C=class extends r{constructor(){super([],"list-namespaces")}};var x=class extends r{constructor(e){let t=`delete-namespace/${e}`;super([],t)}};var E=class{client;constructor(e){this.client=e}namespace=e=>new h(this.client,e);delete=(e,t)=>new p(e,t).exec(this.client);query=(e,t)=>new d(e,t).exec(this.client);upsert=(e,t)=>new m(e,t).exec(this.client);update=(e,t)=>new y(e,t).exec(this.client);fetch=(...e)=>new c(e).exec(this.client);reset=e=>new u(e).exec(this.client);range=(e,t)=>new l(e,t).exec(this.client);info=()=>new T().exec(this.client);listNamespaces=()=>new C().exec(this.client);deleteNamespace=e=>new x(e).exec(this.client)};var b=class n extends E{constructor(e){if(typeof e<"u"&&"request"in e){super(e);return}let t=e?.token??process.env.NEXT_PUBLIC_UPSTASH_VECTOR_REST_TOKEN??process.env.UPSTASH_VECTOR_REST_TOKEN,a=e?.url??process.env.NEXT_PUBLIC_UPSTASH_VECTOR_REST_URL??process.env.UPSTASH_VECTOR_REST_URL;if(!t)throw new Error("UPSTASH_VECTOR_REST_TOKEN is missing!");if(!a)throw new Error("UPSTASH_VECTOR_REST_URL is missing!");(a.startsWith(" ")||a.endsWith(" ")||/\r|\n/.test(a))&&console.warn("The vector url contains whitespace or newline, which can cause errors!"),(t.startsWith(" ")||t.endsWith(" ")||/\r|\n/.test(t))&&console.warn("The vector token contains whitespace or newline, which can cause errors!");let s=new f({baseUrl:a,retry:e?.retry,headers:{authorization:`Bearer ${t}`},cache:e?.cache===!1?void 0:e?.cache||"no-store",signal:e?.signal});super(s)}static fromEnv(e){let t=process?.env.UPSTASH_VECTOR_REST_URL;if(!t)throw new Error("Unable to find environment variable: `UPSTASH_VECTOR_REST_URL`");let a=process?.env.UPSTASH_VECTOR_REST_TOKEN;if(!a)throw new Error("Unable to find environment variable: `UPSTASH_VECTOR_REST_TOKEN`");return new n({...e,url:t,token:a})}};0&&(module.exports={Index});
